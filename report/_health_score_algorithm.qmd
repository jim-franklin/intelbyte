The Machine Health Scoring algorithm converts raw machine signals into a single, easy-to-understand indicator that reflects how healthy a machine is at any moment. The goal is not to predict failure perfectly in the MVP, but to provide a **clear, consistent signal** that helps supervisors and maintenance teams prioritize attention.

Industry platforms often normalize machine health to a **0–100** scale to simplify interpretation for operations and maintenance teams @infiniteUptimeHealthScore. The score combines **three ideas** that are common in industrial monitoring systems:

- **Normal operation** keeps the score high  
- **Abnormal sensor readings** reduce the score gradually  
- **Faults and maintenance states** reduce the score immediately and visibly 

### How often the score is recalculated

The health score is recalculated each time new telemetry is processed for a machine, which in typical industrial environments means every few seconds to every minute, depending on sensor. High frequency signals such as temperature or vibration may arrive every 5–30 seconds, while lower frequency metrics such as throughput or energy usage may arrive every 1–5 minutes.

Rather than recomputing the score from all historical data, the system updates the score incrementally using the previous value. This keeps the score near real-time, computationally efficient, and stable for dashboards, while still reacting quickly when sustained issues or faults appear.

### Where the score is stored

The computed score is written to `CurrentMachineState.healthScore` for each machine:

- Table: `CurrentMachineState`  
- Primary key: `machineId`  
- Foreign keys:  
  - `machineId -> Machine.machineId`  
  - `lastTelemetryEventId -> TelemetryEvent.telemetryEventId`  
  - `lastOperatorReportId -> OperatorReport.operatorReportId`  
- Key fields updated by this algorithm:   
  - `healthScore`  
  - `lastUpdateAt`

This aligns with @tbl-field-level-details.

### Scoring logic overview

At each update, the score is computed using recent machine behavior, not the full telemetry history.

::: {.callout-note appearance="simple"}
### Telemetry Frequency and Rolling Window

For the MVP, machines are assumed to publish telemetry approximately every 30 seconds. A 15 minute rolling window is therefore used for health scoring, providing about 30 samples per metric. This window smooths short-lived sensor noise while remaining responsive to sustained changes in machine condition.
:::

The scoring logic combines:

- The latest telemetry readings, aggregated as rolling averages over a short time window
- Current machine status (`Running`, `Idle`, `Fault`, `UnderMaintenance`)  
- Any active fault codes and their severity (`High`, `Medium`)  
- Operator flags from inspections (`IssueObserved`, `MinorConcern`)  

The annotated pseudocode below shows exactly how each signal contributes to the final score and how the result is stabilized for operational dashboards.

```python
def compute_health_score(previous_score):
    healthScore = 100                                  # <1>
    smoothing_param = 0.2                              # <2>

    # sensor penalties
    healthScore -= temperature_penalty                 # <3>
    healthScore -= vibration_penalty                   # <3>
    healthScore -= throughput_penalty                  # <3>

    # fault severity penalties
    if fault_severity == "High":                       # <4>
        healthScore -= 60
    elif fault_severity == "Medium":
        healthScore -= 30

    # apply operator input only if a report exists
    if operator_flag == "IssueObserved":                # <5>
        healthScore -= 20
    elif operator_flag == "MinorConcern":
        healthScore -= 10

    # maintenance state cap
    if status == "UnderMaintenance":                    # <6>
        healthScore = min(healthScore, 60)

    # smoothing (EWMA)
    healthScore = (                                     # <7>
        smoothing_param * healthScore + 
        (1 - smoothing_param) * previous_score
    )

    # ensure the final score stays between 0 (worst) and 100 (best)
    healthScore = max(0, min(100, healthScore))         # <8>
    
    return healthScore
```
1.	Start from a healthy baseline score of 100 for every evaluation.
2.	Define how strongly the new score reacts to recent data versus the previous score.
3.	Apply penalties based on sensor readings that deviate from normal operating ranges.
4.	Apply a strong penalty when an active fault is detected, scaled by severity.
5.	Incorporate human input from inspections or shift reports when operators flag issues.
6.	Cap the score when the machine is under maintenance to reflect reduced availability.
7.	Smooth the score using an Exponentially Weighted Moving Average to reduce noise.
8.	Ensure the final score always remains between 0 and 100.