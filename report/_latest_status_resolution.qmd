The platform resolves `CurrentMachineState.resolvedStatus` by evaluating multiple signal sources in a fixed order of precedence. This ensures the resulting status is predictable, explainable, and aligned with real operational decision-making.

### Status Precedence

Status precedence ensures maintenance and safety decisions take priority, while allowing the system to automatically return to telemetry driven status when conditions normalize. It is applied as follows (highest wins):

1. **UnderMaintenance**  
   If one or more maintenance work orders are active for a machine, the machine is considered `UnderMaintenance` regardless of telemetry or operator inputs. This condition is represented by `openWorkOrderCount > 0`, derived from `WorkOrder.status`.

2. **Manual operator override**  
   If an operator submits a report containing `statusOverride`, the most recent override is applied while it is still valid. This allows short term safety or inspection decisions to override automated signals.

3. **Telemetry derived status**  
   When neither maintenance nor a manual override is active, the status is derived from the latest telemetry event. If `faultCodeId` is present the status is `Fault`; otherwise the status falls back to the device reported operating state stored in `TelemetryEvent.statusRaw` (for example `Running` or `Idle`).

::: {.callout-note appearance="simple"}
`WorkOrder.status` drives `openWorkOrderCount`. Any non-zero count forces `CurrentMachineState.resolvedStatus = 'UnderMaintenance'` until all active work orders are closed and `openWorkOrderCount` returns to `0`.
:::

::: {.callout-note appearance="simple"}
Operator overrides are intentionally time boxed (example: 4 hours). After the window expires, status resolution automatically falls back to telemetry without requiring manual cleanup.
:::

### Initialization at Launch

This runs once to create the  `CurrentMachineState` at MVP launch. After this, the system stays current via event driven upserts. See @upserts.

```sql
-- Physical table (read model)
CREATE TABLE IF NOT EXISTS CurrentMachineState (
  machineId               BIGINT PRIMARY KEY,
  resolvedStatus          VARCHAR(32) NOT NULL,
  healthScore             NUMERIC(5,2) NULL,
  openWorkOrderCount      INT NOT NULL DEFAULT 0,
  lastTelemetryEventId    BIGINT NULL,
  lastOperatorReportId    BIGINT NULL,
  lastUpdateAt            TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### Event Driven Updates {#upserts}

After the initialization, the platforms performs small targeted updates:

-	When telemetry arrives for a machine, update that machine’s row  
-	When a work order opens or closes for a machine, update that machine’s row  
-	When an operator submits an override for a machine, update that machine’s row  

The query below shows per machine update executed when telemetry, work order or operator override is received for a specific machine.

::: {.callout-note appearance=“simple”}
The SQL code block is executed with parameters supplied by the `Stream Processor`. These parameters are taken directly from the incoming telemetry message from `Telemetry Ingestion API`. They include `:machineId`, `:telemetryEventId`, `:eventTimestamp`, `:statusRaw`, `:faultCodeId`.
:::

```{.sql code-line-numbers="4-30|32-36|38-71|88-97|99-112"}
-- Runs for ONE machine whenever ANY of these events occurs:
-- 1) telemetry event, 2) work order opened/closed, 3) operator override submitted, 4) health score updated.

WITH Incoming AS (
  SELECT
    :machineId                :: BIGINT        AS machineId,

    -- Telemetry event fields (present on telemetry events)
    :telemetryEventId         :: BIGINT        AS telemetryEventId,
    :eventTimestamp           :: TIMESTAMP     AS eventTimestamp,
    :statusRaw                :: VARCHAR(32)   AS statusRaw,
    :faultCodeId              :: BIGINT        AS faultCodeId,

    -- Work order fields (emitted when a work order is created/updated/closed)
    :workOrderId              :: BIGINT        AS workOrderId,
    :workOrderCreatedAt       :: TIMESTAMP     AS workOrderCreatedAt,
    :workOrderClosedAt        :: TIMESTAMP     AS workOrderClosedAt,
    :openWorkOrderCount       :: INT           AS openWorkOrderCount,
    :workOrderCreatedByType   :: VARCHAR(32)   AS workOrderCreatedByType,
    :workOrderCreatedById     :: BIGINT        AS workOrderCreatedById,

    -- Operator report fields (emitted when an operator submits a report/override)
    :operatorReportId         :: BIGINT        AS operatorReportId,
    :reportTimestamp          :: TIMESTAMP     AS reportTimestamp,
    :statusOverride           :: VARCHAR(32)   AS statusOverride,

    -- Health score event fields (present on scoring events)
    :healthScore              :: NUMERIC(5,2)  AS healthScore,
    :healthScoreAt            :: TIMESTAMP     AS healthScoreAt
),

Existing AS (
  SELECT *
  FROM CurrentMachineState
  WHERE machineId = (SELECT machineId FROM Incoming)
),

Merged AS (
  SELECT
    i.machineId,

    -- Keep lastest telemetry
    COALESCE(i.telemetryEventId, e.lastTelemetryEventId) AS lastTelemetryEventId,
    COALESCE(i.eventTimestamp,   e.lastUpdateAt)         AS lastTelemetryAt,
    i.statusRaw                                         AS statusRaw,
    i.faultCodeId                                       AS faultCodeId,

    -- Keep latest work order signals
    COALESCE(i.openWorkOrderCount, e.openWorkOrderCount, 0) AS openWorkOrderCount,
    COALESCE(i.workOrderId, e.lastWorkOrderId) AS lastWorkOrderId,
    COALESCE(i.workOrderCreatedByType, e.lastWorkOrderCreatedByType) AS lastWorkOrderCreatedByType,
    COALESCE(i.workOrderCreatedById,   e.lastWorkOrderCreatedById)   AS lastWorkOrderCreatedById,

    -- Use createdAt/closedAt from the incoming work order event to bump freshness.
    GREATEST(
      COALESCE(i.workOrderCreatedAt, TIMESTAMP '1970-01-01'),
      COALESCE(i.workOrderClosedAt,  TIMESTAMP '1970-01-01'),
      COALESCE(e.lastUpdateAt,       TIMESTAMP '1970-01-01')
    ) AS lastWorkOrderChangeAt,

    -- Keep latest operator override pointer
    COALESCE(i.operatorReportId, e.lastOperatorReportId) AS lastOperatorReportId,
    COALESCE(i.reportTimestamp,  e.lastUpdateAt)         AS lastOverrideAt,
    i.statusOverride                                     AS statusOverride,

    -- Keep latest health score
    COALESCE(i.healthScore,   e.healthScore)             AS healthScore,
    COALESCE(i.healthScoreAt, e.lastUpdateAt)            AS healthScoreAt
  FROM Incoming i
  LEFT JOIN Existing e ON TRUE
)

INSERT INTO CurrentMachineState (
  machineId,
  resolvedStatus,
  healthScore,
  openWorkOrderCount,
  lastTelemetryEventId,
  lastOperatorReportId,
  lastWorkOrderId,
  lastWorkOrderCreatedByType,
  lastWorkOrderCreatedById,
  lastUpdateAt
)
SELECT
  m.machineId,

  CASE
    WHEN m.openWorkOrderCount > 0 THEN 'UnderMaintenance'

    WHEN m.statusOverride IS NOT NULL
      AND m.lastOverrideAt >= CURRENT_TIMESTAMP - INTERVAL '4 hours'
      THEN m.statusOverride

    WHEN m.faultCodeId IS NOT NULL THEN 'Fault'
    ELSE COALESCE(m.statusRaw, 'Idle')
  END AS resolvedStatus,

  m.healthScore,
  m.openWorkOrderCount,
  m.lastTelemetryEventId,
  m.lastOperatorReportId,
  m.lastWorkOrderId,
  m.lastWorkOrderCreatedByType,
  m.lastWorkOrderCreatedById,

  GREATEST(
    COALESCE(m.lastTelemetryAt,         TIMESTAMP '1970-01-01'),
    COALESCE(m.lastWorkOrderChangeAt,   TIMESTAMP '1970-01-01'),
    COALESCE(m.lastOverrideAt,          TIMESTAMP '1970-01-01'),
    COALESCE(m.healthScoreAt,           TIMESTAMP '1970-01-01')
  ) AS lastUpdateAt
FROM Merged m

ON CONFLICT (machineId) DO UPDATE
SET
  resolvedStatus              = EXCLUDED.resolvedStatus,
  healthScore                 = EXCLUDED.healthScore,
  openWorkOrderCount          = EXCLUDED.openWorkOrderCount,
  lastTelemetryEventId        = EXCLUDED.lastTelemetryEventId,
  lastOperatorReportId        = EXCLUDED.lastOperatorReportId,
  lastWorkOrderId             = EXCLUDED.lastWorkOrderId,
  lastWorkOrderCreatedByType  = EXCLUDED.lastWorkOrderCreatedByType,
  lastWorkOrderCreatedById    = EXCLUDED.lastWorkOrderCreatedById,
  lastUpdateAt                = EXCLUDED.lastUpdateAt;
```

::: {.callout-note appearance="simple"}
`CurrentMachineState.lastUpdateAt` represents the most recent time **any part of the machine’s current state changed**. This includes:

- a status change driven by telemetry, work orders, or operator overrides
- an update to `openWorkOrderCount`
- a new `healthScore` written by the Health Scoring Service

Because both status resolution and health scoring update the same read model, `lastUpdateAt` reflects overall **state freshness**, not just telemetry arrival time.
:::
